
R version 4.5.0 (2025-04-11) -- "How About a Twenty-Six"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: aarch64-apple-darwin20

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "permute"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('permute')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("allPerms")
> ### * allPerms
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: allPerms
> ### Title: Complete enumeration of all possible permutations
> ### Aliases: allPerms print.allPerms summary.allPerms
> ###   print.summary.allPerms as.matrix.allPerms as.allPerms
> 
> ### ** Examples
> 
> ## allPerms can work with a vector
> vec <- c(3,4,5)
> allPerms(vec) ## free permutation
     [,1] [,2] [,3]
[1,]    1    3    2
[2,]    2    1    3
[3,]    2    3    1
[4,]    3    1    2
[5,]    3    2    1
> 
> ## enumerate all possible permutations for a more complicated
> ## design
> fac <- gl(2,6)
> ctrl <- how(within = Within(type = "grid", mirror = FALSE,
+                             constant = TRUE, nrow = 3, ncol = 2),
+             plots = Plots(strata = fac))
> Nobs <- length(fac)
> numPerms(seq_len(Nobs), control = ctrl) ## 6
[1] 6
> (tmp <- allPerms(Nobs, control = update(ctrl, observed = TRUE)))
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
[1,]    2    3    4    5    6    1    8    9   10    11    12     7
[2,]    3    4    5    6    1    2    9   10   11    12     7     8
[3,]    4    5    6    1    2    3   10   11   12     7     8     9
[4,]    5    6    1    2    3    4   11   12    7     8     9    10
[5,]    6    1    2    3    4    5   12    7    8     9    10    11
[6,]    1    2    3    4    5    6    7    8    9    10    11    12
> (tmp2 <- allPerms(Nobs, control = ctrl))
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
[1,]    2    3    4    5    6    1    8    9   10    11    12     7
[2,]    3    4    5    6    1    2    9   10   11    12     7     8
[3,]    4    5    6    1    2    3   10   11   12     7     8     9
[4,]    5    6    1    2    3    4   11   12    7     8     9    10
[5,]    6    1    2    3    4    5   12    7    8     9    10    11
> 
> ## turn on mirroring
> ##ctrl$within$mirror <- TRUE
> ctrl <- update(ctrl, within = update(getWithin(ctrl), mirror = TRUE))
> numPerms(seq_len(Nobs), control = ctrl)
[1] 12
> (tmp3 <- allPerms(Nobs, control = update(ctrl, observed = TRUE)))
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
 [1,]    2    3    4    5    6    1    8    9   10    11    12     7
 [2,]    3    4    5    6    1    2    9   10   11    12     7     8
 [3,]    4    5    6    1    2    3   10   11   12     7     8     9
 [4,]    5    6    1    2    3    4   11   12    7     8     9    10
 [5,]    6    1    2    3    4    5   12    7    8     9    10    11
 [6,]    1    2    3    4    5    6    7    8    9    10    11    12
 [7,]    1    6    5    4    3    2    7   12   11    10     9     8
 [8,]    2    1    6    5    4    3    8    7   12    11    10     9
 [9,]    3    2    1    6    5    4    9    8    7    12    11    10
[10,]    4    3    2    1    6    5   10    9    8     7    12    11
[11,]    5    4    3    2    1    6   11   10    9     8     7    12
[12,]    6    5    4    3    2    1   12   11   10     9     8     7
> (tmp4 <- allPerms(Nobs, control = ctrl))
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
 [1,]    2    3    4    5    6    1    8    9   10    11    12     7
 [2,]    3    4    5    6    1    2    9   10   11    12     7     8
 [3,]    4    5    6    1    2    3   10   11   12     7     8     9
 [4,]    5    6    1    2    3    4   11   12    7     8     9    10
 [5,]    6    1    2    3    4    5   12    7    8     9    10    11
 [6,]    1    6    5    4    3    2    7   12   11    10     9     8
 [7,]    2    1    6    5    4    3    8    7   12    11    10     9
 [8,]    3    2    1    6    5    4    9    8    7    12    11    10
 [9,]    4    3    2    1    6    5   10    9    8     7    12    11
[10,]    5    4    3    2    1    6   11   10    9     8     7    12
[11,]    6    5    4    3    2    1   12   11   10     9     8     7
> 
> ## prints out details of the permutation scheme as
> ## well as the matrix of permutations
> summary(tmp3)

	Complete enumeration of permutations

Permutation Design:

Blocks:
  Defined by: none

Plots:
  Plots: fac
  Permutation type: none
  Mirrored?: No

Within Plots:
  Permutation type: grid
  Mirrored?: Yes
  Different permutation within each Plot?: No
  Grid dimensions: 3 rows 2 cols

Permutation details:
  Number of permutations: 199
  Max. number of permutations allowed: 9999
  Evaluate all permutations?: No.  Activation limit: 5040

All permutations:
Contains observed ordering?: Yes 

      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
 [1,]    2    3    4    5    6    1    8    9   10    11    12     7
 [2,]    3    4    5    6    1    2    9   10   11    12     7     8
 [3,]    4    5    6    1    2    3   10   11   12     7     8     9
 [4,]    5    6    1    2    3    4   11   12    7     8     9    10
 [5,]    6    1    2    3    4    5   12    7    8     9    10    11
 [6,]    1    2    3    4    5    6    7    8    9    10    11    12
 [7,]    1    6    5    4    3    2    7   12   11    10     9     8
 [8,]    2    1    6    5    4    3    8    7   12    11    10     9
 [9,]    3    2    1    6    5    4    9    8    7    12    11    10
[10,]    4    3    2    1    6    5   10    9    8     7    12    11
[11,]    5    4    3    2    1    6   11   10    9     8     7    12
[12,]    6    5    4    3    2    1   12   11   10     9     8     7
> summary(tmp4)

	Complete enumeration of permutations

Permutation Design:

Blocks:
  Defined by: none

Plots:
  Plots: fac
  Permutation type: none
  Mirrored?: No

Within Plots:
  Permutation type: grid
  Mirrored?: Yes
  Different permutation within each Plot?: No
  Grid dimensions: 3 rows 2 cols

Permutation details:
  Number of permutations: 198
  Max. number of permutations allowed: 9999
  Evaluate all permutations?: No.  Activation limit: 5040

All permutations:
Contains observed ordering?: No 

      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
 [1,]    2    3    4    5    6    1    8    9   10    11    12     7
 [2,]    3    4    5    6    1    2    9   10   11    12     7     8
 [3,]    4    5    6    1    2    3   10   11   12     7     8     9
 [4,]    5    6    1    2    3    4   11   12    7     8     9    10
 [5,]    6    1    2    3    4    5   12    7    8     9    10    11
 [6,]    1    6    5    4    3    2    7   12   11    10     9     8
 [7,]    2    1    6    5    4    3    8    7   12    11    10     9
 [8,]    3    2    1    6    5    4    9    8    7    12    11    10
 [9,]    4    3    2    1    6    5   10    9    8     7    12    11
[10,]    5    4    3    2    1    6   11   10    9     8     7    12
[11,]    6    5    4    3    2    1   12   11   10     9     8     7
> 
> 
> 
> cleanEx()
> nameEx("check")
> ### * check
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: check
> ### Title: Utility functions for permutation schemes
> ### Aliases: check print.check print.summary.check summary.check
> ### Keywords: utilities design methods
> 
> ### ** Examples
> 
> ## only run this example if vegan is available
> if (suppressPackageStartupMessages(require("vegan"))) {
+     ## use example data from ?pyrifos in package vegan
+     example(pyrifos)
+ 
+     ## Demonstrate the maximum number of permutations for the pyrifos data
+     ## under a series of permutation schemes
+ 
+     ## no restrictions - lots of perms
+     CONTROL <- how(within = Within(type = "free"))
+     (check1 <- check(pyrifos, CONTROL))
+     ## summary(check1)
+     
+     ## no strata but data are series with no mirroring, so 132 permutations
+     CONTROL <- how(within = Within(type = "series", mirror = FALSE))
+     check(pyrifos, CONTROL)
+     
+     ## no strata but data are series with mirroring, so 264 permutations
+     CONTROL <- how(within = Within(type = "series", mirror = TRUE))
+     check(pyrifos, control = CONTROL)
+     
+     ## unrestricted within strata
+     check(pyrifos, control = how(plots = Plots(strata = ditch),
+                    within = Within(type = "free")))
+     
+     ## time series within strata, no mirroring
+     check(pyrifos,
+           control = how(plots = Plots(strata = ditch),
+           within = Within(type = "series", mirror = FALSE)))
+     
+     ## time series within strata, with mirroring
+     check(pyrifos,
+           control = how(plots = Plots(strata = ditch),
+           within = Within(type = "series", mirror = TRUE)))
+     
+     ## time series within strata, no mirroring, same permutation
+     ## within strata
+     check(pyrifos,
+           control = how(plots = Plots(strata = ditch),
+           within = Within(type = "series", constant = TRUE)))
+     
+     ## time series within strata, with mirroring, same permutation
+     ## within strata
+     check(pyrifos,
+           control = how(plots = Plots(strata = ditch),
+           within = Within(type = "series", mirror = TRUE,
+           constant = TRUE)))
+     ## permute strata
+     check(pyrifos, how(plots = Plots(strata = ditch, type = "free"),
+                        within = Within(type = "none")))
+ }

pyrifs> data(pyrifos)

pyrifs> ditch <- gl(12, 1, length=132)

pyrifs> week <- gl(11, 12, labels=c(-4, -1, 0.1, 1, 2, 4, 8, 12, 15, 19, 24))

pyrifs> dose <- factor(rep(c(0.1, 0, 0, 0.9, 0, 44, 6, 0.1, 44, 0.9, 0, 6), 11))
'nperm' >= set of all permutations: complete enumeration.
Set of permutations < 'minperm'. Generating entire set.
Set of permutations < 'minperm'. Generating entire set.
'nperm' >= set of all permutations: complete enumeration.
Set of permutations < 'minperm'. Generating entire set.
'nperm' >= set of all permutations: complete enumeration.
Set of permutations < 'minperm'. Generating entire set.
[1] 479001600
>     
> ## this should also also for arbitrary vectors
> vec1 <- check(1:100)
> vec2 <- check(1:100, how())
> all.equal(vec1, vec2)
[1] TRUE
> vec3 <- check(1:100, how(within = Within(type = "series")))
'nperm' >= set of all permutations: complete enumeration.
Set of permutations < 'minperm'. Generating entire set.
> all.equal(100, vec3$n)
[1] TRUE
> vec4 <- check(1:100, how(within = Within(type= "series", mirror = TRUE)))
'nperm' >= set of all permutations: complete enumeration.
Set of permutations < 'minperm'. Generating entire set.
> all.equal(vec4$n, 200)
[1] TRUE
> 
> ## enumerate all possible permutations
> fac <- gl(2,6)
> ctrl <- how(plots = Plots(strata = fac),
+             within = Within(type = "grid", mirror = FALSE,
+                             constant = TRUE, nrow = 3, ncol = 2))
> check(1:12, ctrl)
'nperm' >= set of all permutations: complete enumeration.
Set of permutations < 'minperm'. Generating entire set.
[1] 6
> 
> numPerms(1:12, control = ctrl)
[1] 6
> (tmp <- allPerms(12, control = update(ctrl, observed = TRUE)))
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
[1,]    2    3    4    5    6    1    8    9   10    11    12     7
[2,]    3    4    5    6    1    2    9   10   11    12     7     8
[3,]    4    5    6    1    2    3   10   11   12     7     8     9
[4,]    5    6    1    2    3    4   11   12    7     8     9    10
[5,]    6    1    2    3    4    5   12    7    8     9    10    11
[6,]    1    2    3    4    5    6    7    8    9    10    11    12
> (tmp2 <- allPerms(12, control = ctrl))
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
[1,]    2    3    4    5    6    1    8    9   10    11    12     7
[2,]    3    4    5    6    1    2    9   10   11    12     7     8
[3,]    4    5    6    1    2    3   10   11   12     7     8     9
[4,]    5    6    1    2    3    4   11   12    7     8     9    10
[5,]    6    1    2    3    4    5   12    7    8     9    10    11
> 
> ## turn on mirroring
> ctrl <- update(ctrl, within = update(getWithin(ctrl), mirror = TRUE))
> numPerms(1:12, control = ctrl)
[1] 12
> (tmp3 <- allPerms(12, control = update(ctrl, observed = TRUE)))
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
 [1,]    2    3    4    5    6    1    8    9   10    11    12     7
 [2,]    3    4    5    6    1    2    9   10   11    12     7     8
 [3,]    4    5    6    1    2    3   10   11   12     7     8     9
 [4,]    5    6    1    2    3    4   11   12    7     8     9    10
 [5,]    6    1    2    3    4    5   12    7    8     9    10    11
 [6,]    1    2    3    4    5    6    7    8    9    10    11    12
 [7,]    1    6    5    4    3    2    7   12   11    10     9     8
 [8,]    2    1    6    5    4    3    8    7   12    11    10     9
 [9,]    3    2    1    6    5    4    9    8    7    12    11    10
[10,]    4    3    2    1    6    5   10    9    8     7    12    11
[11,]    5    4    3    2    1    6   11   10    9     8     7    12
[12,]    6    5    4    3    2    1   12   11   10     9     8     7
> (tmp4 <- allPerms(12, control = ctrl))
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
 [1,]    2    3    4    5    6    1    8    9   10    11    12     7
 [2,]    3    4    5    6    1    2    9   10   11    12     7     8
 [3,]    4    5    6    1    2    3   10   11   12     7     8     9
 [4,]    5    6    1    2    3    4   11   12    7     8     9    10
 [5,]    6    1    2    3    4    5   12    7    8     9    10    11
 [6,]    1    6    5    4    3    2    7   12   11    10     9     8
 [7,]    2    1    6    5    4    3    8    7   12    11    10     9
 [8,]    3    2    1    6    5    4    9    8    7    12    11    10
 [9,]    4    3    2    1    6    5   10    9    8     7    12    11
[10,]    5    4    3    2    1    6   11   10    9     8     7    12
[11,]    6    5    4    3    2    1   12   11   10     9     8     7
> ## prints out details of the permutation scheme as
> ## well as the matrix of permutations
> summary(tmp)

	Complete enumeration of permutations

Permutation Design:

Blocks:
  Defined by: none

Plots:
  Plots: fac
  Permutation type: none
  Mirrored?: No

Within Plots:
  Permutation type: grid
  Mirrored?: No
  Different permutation within each Plot?: No
  Grid dimensions: 3 rows 2 cols

Permutation details:
  Number of permutations: 199
  Max. number of permutations allowed: 9999
  Evaluate all permutations?: No.  Activation limit: 5040

All permutations:
Contains observed ordering?: Yes 

     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
[1,]    2    3    4    5    6    1    8    9   10    11    12     7
[2,]    3    4    5    6    1    2    9   10   11    12     7     8
[3,]    4    5    6    1    2    3   10   11   12     7     8     9
[4,]    5    6    1    2    3    4   11   12    7     8     9    10
[5,]    6    1    2    3    4    5   12    7    8     9    10    11
[6,]    1    2    3    4    5    6    7    8    9    10    11    12
> summary(tmp2)

	Complete enumeration of permutations

Permutation Design:

Blocks:
  Defined by: none

Plots:
  Plots: fac
  Permutation type: none
  Mirrored?: No

Within Plots:
  Permutation type: grid
  Mirrored?: No
  Different permutation within each Plot?: No
  Grid dimensions: 3 rows 2 cols

Permutation details:
  Number of permutations: 198
  Max. number of permutations allowed: 9999
  Evaluate all permutations?: No.  Activation limit: 5040

All permutations:
Contains observed ordering?: No 

     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
[1,]    2    3    4    5    6    1    8    9   10    11    12     7
[2,]    3    4    5    6    1    2    9   10   11    12     7     8
[3,]    4    5    6    1    2    3   10   11   12     7     8     9
[4,]    5    6    1    2    3    4   11   12    7     8     9    10
[5,]    6    1    2    3    4    5   12    7    8     9    10    11
> 
> ## different numbers of observations per level of strata
> fac <- factor(rep(1:3, times = c(3,2,2)))
> ## free permutations in levels of strata
> numPerms(7, how(within = Within(type = "free"),
+                 plots = Plots(strata = fac, type = "none")))
[1] 24
> allPerms(7, how(within = Within(type = "free"),
+                 plots = Plots(strata = fac)))
      [,1] [,2] [,3] [,4] [,5] [,6] [,7]
 [1,]    1    2    3    4    5    7    6
 [2,]    1    2    3    5    4    6    7
 [3,]    1    2    3    5    4    7    6
 [4,]    1    3    2    4    5    6    7
 [5,]    1    3    2    4    5    7    6
 [6,]    1    3    2    5    4    6    7
 [7,]    1    3    2    5    4    7    6
 [8,]    2    1    3    4    5    6    7
 [9,]    2    1    3    4    5    7    6
[10,]    2    1    3    5    4    6    7
[11,]    2    1    3    5    4    7    6
[12,]    2    3    1    4    5    6    7
[13,]    2    3    1    4    5    7    6
[14,]    2    3    1    5    4    6    7
[15,]    2    3    1    5    4    7    6
[16,]    3    1    2    4    5    6    7
[17,]    3    1    2    4    5    7    6
[18,]    3    1    2    5    4    6    7
[19,]    3    1    2    5    4    7    6
[20,]    3    2    1    4    5    6    7
[21,]    3    2    1    4    5    7    6
[22,]    3    2    1    5    4    6    7
[23,]    3    2    1    5    4    7    6
> ## series permutations in levels of strata
> ctrl <- how(within = Within(type = "series"), plots = Plots(strata = fac))
> numPerms(7, control = ctrl)
[1] 12
> allPerms(7, control = ctrl)
      [,1] [,2] [,3] [,4] [,5] [,6] [,7]
 [1,]    2    3    1    5    4    7    6
 [2,]    2    3    1    5    4    6    7
 [3,]    2    3    1    4    5    7    6
 [4,]    2    3    1    4    5    6    7
 [5,]    3    1    2    5    4    7    6
 [6,]    3    1    2    5    4    6    7
 [7,]    3    1    2    4    5    7    6
 [8,]    3    1    2    4    5    6    7
 [9,]    1    2    3    5    4    7    6
[10,]    1    2    3    5    4    6    7
[11,]    1    2    3    4    5    7    6
> 
> 
> 
> cleanEx()

detaching ‘package:vegan’

> nameEx("get-methods")
> ### * get-methods
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get-methods
> ### Title: Extractor functions to access components of a permutation design
> ### Aliases: get-methods getBlocks getBlocks.default getBlocks.how
> ###   getBlocks.permControl getWithin getWithin.default getWithin.how
> ###   getWithin.permControl getStrata getStrata.default getStrata.how
> ###   getStrata.permControl getStrata.Plots getType getType.default
> ###   getType.how getType.permControl getType.Plots getType.Within
> ###   getMirror getMirror.default getMirror.how getMirror.permControl
> ###   getMirror.Plots getMirror.Within getConstant getConstant.default
> ###   getConstant.how getConstant.permControl getConstant.Within getPlots
> ###   getPlots.default getPlots.how getPlots.permControl getRow
> ###   getRow.default getRow.how getRow.permControl getRow.Plots
> ###   getRow.Within getCol getCol.default getCol.how getCol.permControl
> ###   getCol.Plots getCol.Within getDim getDim.default getDim.how
> ###   getDim.permControl getDim.Plots getDim.Within getNperm
> ###   getNperm.default getNperm.how getNperm.permControl getMaxperm
> ###   getMaxperm.default getMaxperm.how getMaxperm.permControl getMinperm
> ###   getMinperm.default getMinperm.how getMinperm.permControl getComplete
> ###   getComplete.default getComplete.how getComplete.permControl getMake
> ###   getMake.default getMake.how getObserved getObserved.default
> ###   getObserved.how getAllperms getAllperms.default getAllperms.how
> ###   getControl getHow getControl.default getControl.allPerms
> ### Keywords: methods utils
> 
> ### ** Examples
> 
> ## extract components from a "how" object
> hh <- how()
> getWithin(hh)
$type
[1] "free"

$constant
[1] FALSE

$mirror
[1] FALSE

$ncol
NULL

$nrow
NULL

$call
Within()

attr(,"class")
[1] "Within"
> getNperm(hh)
[1] 199
> 
> 
> 
> cleanEx()
> nameEx("how")
> ### * how
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: how
> ### Title: How to define a permutation design?
> ### Aliases: how print.how Blocks Within Plots
> ### Keywords: utils
> 
> ### ** Examples
> 
> ## Set up factors for the Plots and Blocks
> plts <- gl(4, 10) ## 4 Plots of 10 samples each
> blks <- gl(2, 20) ## 2 Blocks of 20 samples each
> 
> ## permutation design
> h1 <- how(within = Within(type = "series", mirror = TRUE),
+           plots = Plots(strata = plts, type = "series"),
+           blocks = blks)
> 
> ## The design can be updated...
> ## ... remove the blocking:
> update(h1, blocks = NULL)

Permutation Design:

Blocks:
  Defined by: none

Plots:
  Plots: plts
  Permutation type: series
  Mirrored?: No

Within Plots:
  Permutation type: series
  Mirrored?: Yes
  Different permutation within each Plot?: Yes

Permutation details:
  Number of permutations: 199
  Max. number of permutations allowed: 9999
  Evaluate all permutations?: No.  Activation limit: 5040
> 
> ## ... or switch the type of shuffling at a level:
> #update(h1, plots = update(getPlots(h1), type = "none"))
> plots2 <- update(getPlots(h1), type = "none")
> update(h1, plots = plots2)

Permutation Design:

Blocks:
  Blocks: blks

Plots:
  Plots: plts
  Permutation type: none
  Mirrored?: No

Within Plots:
  Permutation type: series
  Mirrored?: Yes
  Different permutation within each Plot?: Yes

Permutation details:
  Number of permutations: 199
  Max. number of permutations allowed: 9999
  Evaluate all permutations?: No.  Activation limit: 5040
> 
> 
> 
> cleanEx()
> nameEx("jackal")
> ### * jackal
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: jackal
> ### Title: Mandible lengths of male and female golden jackals
> ### Aliases: jackal
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(jackal)
> str(jackal)
'data.frame':	20 obs. of  2 variables:
 $ Length: num  120 107 110 116 114 111 113 117 114 112 ...
 $ Sex   : Factor w/ 2 levels "Male","Female": 1 1 1 1 1 1 1 1 1 1 ...
> 
> ## boxplot of mandible length vs sex
> plot(Length ~ Sex, data = jackal)
> 
> 
> 
> cleanEx()
> nameEx("nobs")
> ### * nobs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nobs-methods
> ### Title: Number of observations in a given object
> ### Aliases: nobs-methods nobs.numeric nobs.integer nobs.matrix
> ###   nobs.data.frame nobs.factor nobs.character
> 
> ### ** Examples
> 
> ## Don't show: 
> suppressWarnings(RNGversion("3.5.0"))
> ## End(Don't show)
> set.seed(1)
> ## numeric vector
> len <- sample(1:10, 1)
> v <- as.numeric(sample(1:100, len))
> len
[1] 3
> obs <- nobs(v)
> isTRUE(all.equal(len, obs))
[1] TRUE
> 
> ## integer
> len <- sample(1L:10L, 1)
> obs <- nobs(len)
> isTRUE(all.equal(len, obs))
[1] FALSE
> 
> 
> 
> 
> cleanEx()
> nameEx("numPerms")
> ### * numPerms
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: numPerms
> ### Title: Number of possible permutations for a given object
> ### Aliases: numPerms
> 
> ### ** Examples
> 
> ## permutation design --- see ?how
> ctrl <- how() ## defaults to freely exchangeable
> 
> ## vector input
> v <- 1:10
> (obs <- nobs(v))
[1] 10
> numPerms(v, control = ctrl)
[1] 3628800
> 
> ## integer input
> len <- length(v)
> (obs <- nobs(len))
[1] 1
> numPerms(len, control = ctrl)
[1] 3628800
> 
> ## new design, objects are a time series
> ctrl <- how(within = Within(type = "series"))
> numPerms(v, control = ctrl)
[1] 10
> ## number of permutations possible drastically reduced...
> ## ...turn on mirroring
> ctrl <- how(within = Within(type = "series", mirror = TRUE))
> numPerms(v, control = ctrl)
[1] 20
> 
> ## Try blocking --- 2 groups of 5
> bl <- numPerms(v, control = how(blocks = gl(2,5)))
> bl
[1] 14400
> 
> ## should be same as
> pl <- numPerms(v, control = how(plots = Plots(strata = gl(2,5))))
> pl
[1] 14400
> stopifnot(all.equal(bl, pl))
> 
> 
> 
> cleanEx()
> nameEx("set-methods")
> ### * set-methods
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: set-methods
> ### Title: Replacement functions to set components of a permutation design
> ### Aliases: set-methods setBlocks<- setBlocks<-.default setBlocks<-.how
> ###   setBlocks<-.permControl setWithin<- setWithin<-.default
> ###   setWithin<-.how setStrata<- setStrata<-.default setStrata<-.how
> ###   setStrata<-.Plots setType<- setType<-.default setType<-.how
> ###   setType<-.Plots setType<-.Within setMirror<- setMirror<-.default
> ###   setMirror<-.how setMirror<-.Plots setMirror<-.Within setConstant<-
> ###   setConstant<-.default setConstant<-.how setConstant<-.Plots
> ###   setConstant<-.Within setPlots<- setPlots<-.default setPlots<-.how
> ###   setRow<- setRow<-.default setRow<-.how setRow<-.Plots setRow<-.Within
> ###   setCol<- setCol<-.default setCol<-.how setCol<-.Plots setCol<-.Within
> ###   setDim<- setDim<-.default setDim<-.how setDim<-.Plots setDim<-.Within
> ###   setNperm<- setNperm<-.default setNperm<-.how setNperm<-.permControl
> ###   setAllperms<- setAllperms<-.default setAllperms<-.how
> ###   setAllperms<-.permControl setMaxperm<- setMaxperm<-.default
> ###   setMaxperm<-.how setMaxperm<-.permControl setMinperm<-
> ###   setMinperm<-.default setMinperm<-.how setMinperm<-.permControl
> ###   setComplete<- setComplete<-.default setComplete<-.how
> ###   setComplete<-.permControl setMake<- setMake<-.default setMake<-.how
> ###   setObserved<- setObserved<-.default setObserved<-.how
> ### Keywords: methods utils
> 
> ### ** Examples
> 
> ## extract components from a "how" object
> hh <- how()
> getNperm(hh)
[1] 199
> setNperm(hh) <- 999
> getNperm(hh)
[1] 999
> 
> 
> 
> cleanEx()
> nameEx("shuffle-utils")
> ### * shuffle-utils
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: shuffle-utils
> ### Title: Utility functions for unrestricted and restricted permutations
> ### Aliases: shuffle-utils shuffleFree shuffleGrid shuffleSeries
> ###   shuffleStrata
> ### Keywords: htest design
> 
> ### ** Examples
> 
> ## Don't show: 
> suppressWarnings(RNGversion("3.5.0"))
> ## End(Don't show)
> set.seed(3)
> 
> ## draw 1 value at random from the set 1:10
> shuffleFree(1:10, 1)
[1] 2
> 
> ## permute the series 1:10
> x <- 1:10
> shuffleSeries(x)                ## with random starting point
 [1] 10  1  2  3  4  5  6  7  8  9
> shuffleSeries(x, start = 5L)    ## known starting point
 [1]  6  7  8  9 10  1  2  3  4  5
> shuffleSeries(x, flip = TRUE)   ## random start, forced mirror
 [1]  5  6  7  8  9 10  1  2  3  4
> shuffleSeries(x, mirror = TRUE) ## random start, possibly mirror
 [1]  5  6  7  8  9 10  1  2  3  4
> 
> ## permute a grid of size 3x3
> shuffleGrid(3, 3)                      ## random starting row/col
[1] 6 4 5 9 7 8 3 1 2
> shuffleGrid(3, 3, start.row = 2,
+             start.col = 3)             ## with known row/col
[1] 3 1 2 6 4 5 9 7 8
> shuffleGrid(3, 3, flip = rep(TRUE, 2)) ## random start, forced mirror
[1] 8 9 7 2 3 1 5 6 4
> 
> 
> 
> cleanEx()
> nameEx("shuffle")
> ### * shuffle
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: shuffle
> ### Title: Unrestricted and restricted permutations
> ### Aliases: shuffle permute
> ### Keywords: htest design
> 
> ### ** Examples
> 
> ## Don't show: 
> suppressWarnings(RNGversion("3.5.0"))
> ## End(Don't show)
> set.seed(1234)
> 
> ## unrestricted permutations
> shuffle(20)
 [1]  3 12 11 18 14 10  1  4  8  6  7  5 20 15  2  9 17 16 19 13
> 
> ## observations represent a time series of line transect
> CTRL <- how(within = Within(type = "series"))
> shuffle(20, control = CTRL)
 [1]  8  9 10 11 12 13 14 15 16 17 18 19 20  1  2  3  4  5  6  7
> 
> ## observations represent a time series of line transect
> ## but with mirroring allowed
> CTRL <- how(within = Within(type = "series", mirror = TRUE))
> shuffle(20, control = CTRL)
 [1]  7  6  5  4  3  2  1 20 19 18 17 16 15 14 13 12 11 10  9  8
> 
> ## observations represent a spatial grid, 5rx4c
> nr <- 5
> nc <- 4
> CTRL <- how(within = Within(type = "grid", ncol = nc, nrow = nr))
> perms <- shuffle(20, control = CTRL)
> ## view the permutation as a grid
> matrix(matrix(1:20, nrow = nr, ncol = nc)[perms],
+        ncol = nc, nrow = nr)
     [,1] [,2] [,3] [,4]
[1,]    7   12   17    2
[2,]    8   13   18    3
[3,]    9   14   19    4
[4,]   10   15   20    5
[5,]    6   11   16    1
> 
> ## random permutations in presence of strata
> plots <- Plots(strata = gl(4, 5))
> CTRL <- how(plots = plots, within = Within(type = "free"))
> shuffle(20, CTRL)
 [1]  5  3  4  2  1  8  7  6  9 10 14 11 15 12 13 18 20 16 17 19
> ## as above but same random permutation within strata
> CTRL <- how(plots = plots, within = Within(type = "free",
+             constant = TRUE))
> shuffle(20, CTRL)
 [1]  3  5  2  1  4  8 10  7  6  9 13 15 12 11 14 18 20 17 16 19
> 
> ## time series within each level of block
> CTRL <- how(plots = plots, within = Within(type = "series"))
> shuffle(20, CTRL)
 [1]  2  3  4  5  1  8  9 10  6  7 15 11 12 13 14 19 20 16 17 18
> ## as above, but  with same permutation for each level
> CTRL <- how(plots = plots, within = Within(type = "series",
+             constant = TRUE))
> shuffle(20, CTRL)
 [1]  2  3  4  5  1  7  8  9 10  6 12 13 14 15 11 17 18 19 20 16
> 
> ## spatial grids within each level of block, 4 x (5r x 5c)
> nr <- 5
> nc <- 5
> nb <- 4 ## number of blocks
> plots <- Plots(gl(nb, 25))
> CTRL <- how(plots = plots,
+             within = Within(type = "grid", ncol = nc, nrow = nr))
> shuffle(100, CTRL)
  [1]  24  25  21  22  23   4   5   1   2   3   9  10   6   7   8  14  15  11
 [19]  12  13  19  20  16  17  18  27  28  29  30  26  32  33  34  35  31  37
 [37]  38  39  40  36  42  43  44  45  41  47  48  49  50  46  56  57  58  59
 [55]  60  61  62  63  64  65  66  67  68  69  70  71  72  73  74  75  51  52
 [73]  53  54  55  83  84  85  81  82  88  89  90  86  87  93  94  95  91  92
 [91]  98  99 100  96  97  78  79  80  76  77
> ## as above, but with same permutation for each level
> CTRL <- how(plots = plots,
+             within = Within(type = "grid", ncol = nc, nrow = nr,
+                             constant = TRUE))
> shuffle(100, CTRL)
  [1]  23  24  25  21  22   3   4   5   1   2   8   9  10   6   7  13  14  15
 [19]  11  12  18  19  20  16  17  48  49  50  46  47  28  29  30  26  27  33
 [37]  34  35  31  32  38  39  40  36  37  43  44  45  41  42  73  74  75  71
 [55]  72  53  54  55  51  52  58  59  60  56  57  63  64  65  61  62  68  69
 [73]  70  66  67  98  99 100  96  97  78  79  80  76  77  83  84  85  81  82
 [91]  88  89  90  86  87  93  94  95  91  92
> 
> ## permuting levels of plots instead of observations
> CTRL <- how(plots = Plots(gl(4, 5), type = "free"),
+             within = Within(type = "none"))
> shuffle(20, CTRL)
 [1] 11 12 13 14 15  1  2  3  4  5  6  7  8  9 10 16 17 18 19 20
> ## permuting levels of plots instead of observations
> ## but plots represent a time series
> CTRL <- how(plots = Plots(gl(4, 5), type = "series"),
+             within = Within(type = "none"))
> shuffle(20, CTRL)
 [1]  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20  1  2  3  4  5
> 
> ## permuting levels of plots but plots represent a time series
> ## free permutation within plots
> CTRL <- how(plots = Plots(gl(4, 5), type = "series"),
+             within = Within(type = "free"))
> shuffle(20, CTRL)
 [1] 12 11 13 14 15 16 20 19 17 18  1  2  3  4  5  6  8 10  7  9
> 
> ## permuting within blocks
> grp <- gl(2, 10) # 2 groups of 10 samples each
> CTRL <- how(blocks = grp)
> shuffle(length(grp), control = CTRL)
 [1]  1  3  6 10  4  2  7  8  9  5 12 14 11 15 18 17 16 19 20 13
> 
> ## Simple function using permute() to assess significance
> ## of a t.test  
> pt.test <- function(x, group, control) {
+     ## function to calculate t
+     t.statistic <- function(x, y) {
+         m <- length(x)
+         n <- length(y)
+         ## means and variances, but for speed
+         xbar <- mean(x)
+         ybar <- mean(y)
+         xvar <- var(x)
+         yvar <- var(y)
+         pooled <- sqrt(((m-1)*xvar + (n-1)*yvar) / (m+n-2))
+         (xbar - ybar) / (pooled * sqrt(1/m + 1/n))
+     }
+     ## check the control object
+     #control <- check(x, control)$control ## FIXME
+     ## number of observations
+     Nobs <- nobs(x)
+     ## group names
+     lev <- names(table(group))
+     ## vector to hold results, +1 because of observed t
+     t.permu <- numeric(length = control$nperm) + 1
+     ## calculate observed t
+     t.permu[1] <- t.statistic(x[group == lev[1]], x[group == lev[2]])
+     ## generate randomisation distribution of t
+     for(i in seq_along(t.permu)) {
+         ## return a permutation
+         want <- permute(i, Nobs, control)
+         ## calculate permuted t
+         t.permu[i+1] <- t.statistic(x[want][group == lev[1]],
+                                     x[want][group == lev[2]])
+     }
+     ## pval from permutation test
+     pval <- sum(abs(t.permu) >= abs(t.permu[1])) / (control$nperm + 1)
+     ## return value
+     return(list(t.stat = t.permu[1], pval = pval))
+ }
> 
> ## generate some data with slightly different means
> set.seed(1234)
> gr1 <- rnorm(20, mean = 9)
> gr2 <- rnorm(20, mean = 10)
> dat <- c(gr1, gr2)
> ## grouping variable
> grp <- gl(2, 20, labels = paste("Group", 1:2))
> ## create the permutation design
> control <- how(nperm = 999, within = Within(type = "free"))
> ## perform permutation t test
> perm.val <- pt.test(dat, grp, control)
> perm.val
$t.stat
[1] -2.342064

$pval
[1] 0.024

> 
> ## compare perm.val with the p-value from t.test()
> t.test(dat ~ grp, var.equal = TRUE)

	Two Sample t-test

data:  dat by grp
t = -2.3421, df = 38, p-value = 0.02452
alternative hypothesis: true difference in means between group Group 1 and group Group 2 is not equal to 0
95 percent confidence interval:
 -1.25582408 -0.09136416
sample estimates:
mean in group Group 1 mean in group Group 2 
             8.749336              9.422930 

> 
> 
> 
> cleanEx()
> nameEx("shuffleSet")
> ### * shuffleSet
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: shuffleSet
> ### Title: Generate a set of permutations from the specified design.
> ### Aliases: shuffleSet as.matrix.permutationMatrix
> ### Keywords: htest design
> 
> ### ** Examples
> 
> ## Don't show: 
> suppressWarnings(RNGversion("3.5.0"))
> ## End(Don't show)
> set.seed(1)
> ## simple random permutations, 5 permutations in set
> shuffleSet(n = 10, nset = 5)
No. of Permutations: 5
No. of Samples: 10 (Randomised)

    1 2 3  4  5  6 7 8  9 10
p1  3 4 5  7  2  8 9 6 10  1
p2  3 2 6 10  5  7 8 4  1  9
p3 10 2 6  1  9  8 7 5  3  4
p4  5 6 4  2 10  8 9 1  7  3
p5  9 6 7  4  8 10 1 2  3  5
> 
> ## series random permutations, 5 permutations in set
> shuffleSet(10, 5, how(within = Within(type = "series")))
Set of permutations < 'minperm'. Generating entire set.
No. of Permutations: 5
No. of Samples: 10 (Sequence)

   1 2  3 4  5  6 7  8  9 10
p1 6 7  8 9 10  1 2  3  4  5
p2 8 9 10 1  2  3 4  5  6  7
p3 5 6  7 8  9 10 1  2  3  4
p4 3 4  5 6  7  8 9 10  1  2
p5 2 3  4 5  6  7 8  9 10  1
> 
> ## series random permutations, 10 permutations in set,
> ## with possible mirroring
> CTRL <- how(within = Within(type = "series", mirror = TRUE))
> shuffleSet(10, 10, CTRL)
Set of permutations < 'minperm'. Generating entire set.
No. of Permutations: 10
No. of Samples: 10 (Sequence; mirrored)

     1 2  3  4  5  6  7  8 9 10
p1   3 4  5  6  7  8  9 10 1  2
p2   7 8  9 10  1  2  3  4 5  6
p3  10 1  2  3  4  5  6  7 8  9
p4   2 1 10  9  8  7  6  5 4  3
p5   8 9 10  1  2  3  4  5 6  7
p6   4 3  2  1 10  9  8  7 6  5
p7   5 6  7  8  9 10  1  2 3  4
p8   9 8  7  6  5  4  3  2 1 10
p9   5 4  3  2  1 10  9  8 7  6
p10  6 5  4  3  2  1 10  9 8  7
> 
> ## Permuting strata
> ## 4 groups of 5 observations
> CTRL <- how(within = Within(type = "none"),
+             plots = Plots(strata = gl(4,5), type = "free"))
> shuffleSet(20, 10, control = CTRL)
Set of permutations < 'minperm'. Generating entire set.
No. of Permutations: 10
No. of Samples: 20 (Nested in: plots; )
Restricted by Plots: gl(4, 5) (4 plots; Randomised)

     1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
p1   6  7  8  9 10  1  2  3  4  5 11 12 13 14 15 16 17 18 19 20
p2   6  7  8  9 10 16 17 18 19 20 11 12 13 14 15  1  2  3  4  5
p3  11 12 13 14 15 16 17 18 19 20  6  7  8  9 10  1  2  3  4  5
p4   1  2  3  4  5 11 12 13 14 15  6  7  8  9 10 16 17 18 19 20
p5  16 17 18 19 20  6  7  8  9 10 11 12 13 14 15  1  2  3  4  5
p6   6  7  8  9 10  1  2  3  4  5 16 17 18 19 20 11 12 13 14 15
p7  11 12 13 14 15  6  7  8  9 10 16 17 18 19 20  1  2  3  4  5
p8  16 17 18 19 20 11 12 13 14 15  6  7  8  9 10  1  2  3  4  5
p9  11 12 13 14 15 16 17 18 19 20  1  2  3  4  5  6  7  8  9 10
p10 16 17 18 19 20  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
> 
> ## 10 random permutations in presence of Plot-level strata
> plotStrata <- Plots(strata = gl(4,5))
> CTRL <- how(plots = plotStrata,
+             within = Within(type = "free"))
> numPerms(20, control = CTRL)
[1] 207360000
> shuffleSet(20, 10, control = CTRL)
No. of Permutations: 10
No. of Samples: 20 (Nested in: plots; Randomised)
Restricted by Plots: gl(4, 5) (4 plots)

    1 2 3 4 5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
p1  5 4 2 3 1  8 10  7  6  9 12 13 11 14 15 17 16 20 18 19
p2  4 2 5 3 1  9  7  6 10  8 12 11 15 13 14 20 18 17 16 19
p3  1 3 5 4 2 10  7  9  6  8 13 15 11 14 12 18 16 19 17 20
p4  3 5 2 4 1  9  8  6 10  7 13 11 15 14 12 19 18 16 20 17
p5  1 3 5 4 2  7  9 10  8  6 13 11 12 15 14 19 20 18 16 17
p6  5 3 4 2 1  7  6  8 10  9 11 14 13 12 15 19 17 16 20 18
p7  3 1 5 4 2  7  6 10  9  8 13 15 11 14 12 20 16 18 17 19
p8  2 3 4 5 1  7  6  9 10  8 13 12 11 15 14 17 16 20 18 19
p9  4 3 2 1 5  7  8  9  6 10 12 15 11 13 14 19 20 17 18 16
p10 1 5 2 4 3  8  7  6  9 10 11 15 13 12 14 16 20 17 19 18
> ## as above but same random permutation within Plot-level strata
> CTRL <- how(plots = plotStrata,
+             within = Within(type = "free", constant = TRUE))
> numPerms(20, control = CTRL)
[1] 120
> shuffleSet(20, 10, CTRL) ## check this.
Set of permutations < 'minperm'. Generating entire set.
No. of Permutations: 10
No. of Samples: 20 (Nested in: plots; Randomised; same permutation in
each plot)
Restricted by Plots: gl(4, 5) (4 plots)

    1 2 3 4 5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
p1  1 5 4 3 2  6 10  9  8  7 11 15 14 13 12 16 20 19 18 17
p2  2 3 1 5 4  7  8  6 10  9 12 13 11 15 14 17 18 16 20 19
p3  1 5 4 2 3  6 10  9  7  8 11 15 14 12 13 16 20 19 17 18
p4  3 2 4 1 5  8  7  9  6 10 13 12 14 11 15 18 17 19 16 20
p5  4 3 5 2 1  9  8 10  7  6 14 13 15 12 11 19 18 20 17 16
p6  1 2 5 3 4  6  7 10  8  9 11 12 15 13 14 16 17 20 18 19
p7  3 4 1 2 5  8  9  6  7 10 13 14 11 12 15 18 19 16 17 20
p8  5 1 3 4 2 10  6  8  9  7 15 11 13 14 12 20 16 18 19 17
p9  2 5 1 3 4  7 10  6  8  9 12 15 11 13 14 17 20 16 18 19
p10 1 3 2 4 5  6  8  7  9 10 11 13 12 14 15 16 18 17 19 20
> 
> ## time series within each level of Plot strata
> CTRL <- how(plots = plotStrata,
+             within = Within(type = "series"))
> shuffleSet(20, 10, CTRL)
Set of permutations < 'minperm'. Generating entire set.
No. of Permutations: 10
No. of Samples: 20 (Nested in: plots; Sequence)
Restricted by Plots: gl(4, 5) (4 plots)

    1 2 3 4 5  6  7 8  9 10 11 12 13 14 15 16 17 18 19 20
p1  2 3 4 5 1 10  6 7  8  9 14 15 11 12 13 18 19 20 16 17
p2  3 4 5 1 2 10  6 7  8  9 12 13 14 15 11 17 18 19 20 16
p3  2 3 4 5 1 10  6 7  8  9 11 12 13 14 15 18 19 20 16 17
p4  2 3 4 5 1 10  6 7  8  9 13 14 15 11 12 19 20 16 17 18
p5  3 4 5 1 2  7  8 9 10  6 14 15 11 12 13 19 20 16 17 18
p6  3 4 5 1 2  7  8 9 10  6 15 11 12 13 14 17 18 19 20 16
p7  2 3 4 5 1 10  6 7  8  9 13 14 15 11 12 18 19 20 16 17
p8  1 2 3 4 5  6  7 8  9 10 13 14 15 11 12 17 18 19 20 16
p9  3 4 5 1 2 10  6 7  8  9 12 13 14 15 11 18 19 20 16 17
p10 4 5 1 2 3  9 10 6  7  8 14 15 11 12 13 18 19 20 16 17
> ## as above, but  with same permutation for each Plot-level stratum
> CTRL <- how(plots = plotStrata,
+             within = Within(type = "series", constant = TRUE))
> shuffleSet(20, 10, CTRL)
'nperm' >= set of all permutations: complete enumeration.
Set of permutations < 'minperm'. Generating entire set.
No. of Permutations: 4
No. of Samples: 20 (Nested in: plots; Sequence; same permutation in
each plot)
Restricted by Plots: gl(4, 5) (4 plots)

   1 2 3 4 5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
p1 2 3 4 5 1  7  8  9 10  6 12 13 14 15 11 17 18 19 20 16
p2 3 4 5 1 2  8  9 10  6  7 13 14 15 11 12 18 19 20 16 17
p3 4 5 1 2 3  9 10  6  7  8 14 15 11 12 13 19 20 16 17 18
p4 5 1 2 3 4 10  6  7  8  9 15 11 12 13 14 20 16 17 18 19
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.621 0.046 0.689 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
